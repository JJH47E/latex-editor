\ifnum\month<10 \edef\month{0\the\month}\else	\edef\month{\the\month}\fi
\ifnum\day<10	\edef\day{0\the\day}\else \edef\day{\the\day}\fi
\documentclass[%
%produce,% Uncomment this line to produce xeindex.sty
]{codedoc}

\usepackage{xeindex}

\usepackage{silence,xcolor,xltxtra}
\WarningFilter{latex}{Marginpar}
\setmainfont[Mapping=tex-text]{Bodoni MT}
\setmonofont[Mapping=tex-text,Scale=.75]{Lucida Console}
\setsansfont[Mapping=tex-text]{Arial}
\usepackage[paperwidth=23cm,paperheight=17.5cm,top=1.5cm,bottom=1.5cm,textwidth=14.5cm,right=1.5cm]{geometry}

\ProduceFile{xeindex.sty}[xeindex][v.0.3][\the\year/\month/\day]
\let\printmacro\PrintMacro
\newskip\macroskip
\def\PrintMacro#1{%
  \ifdim\macroskip=0pt
    \midbreak
  \fi
  \noindent
  \setbox0=\hbox{%
    \lower\macroskip\hbox{%
      \llap{%
        \textcolor{red!80!black}{\texttt{#1}}%
        \enspace
        }%
      }%
    }%
  \dp0=0pt
  \box0
  \macroskip0pt
  \ignorespaces
  }
\ShortVerb"
\CodeFont{\ttfamily\color{red!80!black}}
\LineNumber{code}{\footnotesize}{1em}

\newskip\midskip
\midskip=6pt plus 4pt minus 4pt
\def\midbreak{\vskip\midskip}
\RenewExample{example}{\ttfamily#}{}{\midbreak\noindent\CodeInput\midbreak}

\title{\FileName\\\FileVersion}
\author{Paul Isambert\\\texttt{zappathustra@free.fr}}
\date{\FileDate}

\def\xeindex{\Xe\kern-.1em Index}
\def\xesearch{\Xe\kern-.1em Search}
\def\XeLaTeX{\Xe\kern-.1em L\kern-.3em\raise.15em\hbox{\scriptsize A}\kern-.1em\TeX}
\SearchList{logos}{\csname#1\endcsname}{xe?,*Xe?}
\SearchList{logos2}{\XeTeX}{xetex}

\begin{document}

%\maketitle

{\Huge\hfill\FileName}\par
\hfill\FileVersion\ – \FileDate\par
{\it \hfill(I simply added a missing comment sign after 4 years of inactivity.\par
\hfill The problem was spotted by Tomas Jonsson.)\par}
\hfill Paul Isambert – \texttt{zappathustra@free.fr}\par


\begin{abstract}
xeindex is a package based on xesearch that automatically
indexes words in a XeLaTeX document. Words or phrases
(possibly underspecified) are declared in a list and
each of their occurrences then creates an index entry,
whose content might be freely specified beforehand.
\end{abstract}

\thispagestyle{empty}
Automatic indexes are bad. You know that. Hence the severe
look of this documentation. So: don't use xeindex.
Or: use it as a tool to generate an index whose relevance
you then check. Or: use it for entries that are generally indexed
on every occurrence, like proper names. Or: do bad indexes.

You load xeindex in the usual way:

\VerbCommand!()
\begin{example}
!StopSearching()\usepackage{xeindex}
\end{example}
\UndoVerbCommand

\noindent
There's only one package option, namely \texttt{mark}, which
prefixes all index entries generated by xeindex with
"***["\meta{word}":"\meta{line number}"]", where \meta{word}
is the word that generated the entry and \meta{line number}
the line where you can find it in the ".tex" file. Moreover,
if a word appears more than once on a page, and thus generates
several index entries although they'll be merged in the
typeset index, with this option each entry is listed along
with each occurrence of the word.
So these entries end up at the beginning of the index, sorted with
symbols, apart from the entries generated by the usual
"\index" command. Thus they can be easily checked and prevented
if irrelevant.

\DescribeMacro\makeindex\macroskip\baselineskip
\DescribeMacro\printindex\macroskip2\baselineskip
\DescribeMacro{\index\marg{entry}}
xeindex loads the \texttt{makeidx} package, so "\makeindex" and "\printindex",
which should be executed as usual, as well as the usual "\index" command,
are available. (If you don't know what I'm talking about, then you
don't know how to produce an index. You should read the \texttt{makeidx}
documentation at least, or the rest of this document might seem cryptic.)

\DescribeMacro{\IndexList\meta{*}\marg{name}\marg{list of entries}}
This is xeindex's main command. The star is optional and \meta{list of entries} is
made of \meta{word}\textcolor{red!80!black}{$=$\meta{entry}} pairs
separated by commas, with the part in red optional too.
Let's see the simplest possibility first:

\begin{example}
\IndexList{mylist}{alley cat,dog,gnu}
\end{example}

\noindent
This will index \emph{alley cat} on every occurrence of \emph{alley cat}
in your document, \emph{dog} on every occurrence of \emph{dog},
and \emph{gnu} on every occurrence of \emph{gnu}.
But this will also index \emph{alley cat} when seeing \emph{Alley cat},
\emph{dog} when seeing \emph{dOg}, and \emph{gnu} when
seeing \emph{GNU}. In other words, xeindex is case-%
insensitive by default, and the index entries are put
in lower case. Most of the time, that's useful. But a gnu
is not GNU, so sometimes you want a different behavior.
In this case, put a "*" before the word, e.g.:

\begin{example}
\IndexList{mylist}{alley cat,DOG,gnu,*GNU}
\end{example}

\noindent
Now xeindex will index \emph{gnu} when seeing \emph{gnu}
or \emph{Gnu}, but it will index \emph{GNU} when seeing
\emph{GNU}. Note that \texttt{DOG} without a star will
index \emph{dog} in any case display, and the index entry
will be \emph{dog}, not \emph{DOG}.
You can also make a whole list case-sensitive,
by adding the star just after "\IndexList", as in:

\begin{example}
\IndexList{mylist}{alley cat,dog,gnu}
\IndexList*{mylist}{GNU}
\end{example}

\noindent
All words in a "*"-marked list are case-sensitive, and
you should not add another star before them. Note that you
can use the same list with different case-sensitivies each
time, as in the above example.

Case-sensitity is useful mostly to index proper names.

\midbreak

The words in a list need not be fully specified. You can
index all words beginning or ending with some letters. To
do so, use "?" for the unspecified part. For instance,

\begin{example}
\IndexList{mylist}{cat?,?mals,*?NU}
\end{example}

\noindent
will find and index \emph{cat}, \emph{cats}, \emph{catheter},
\emph{animals}, \emph{mammals}, \emph{GNU}, \emph{gNU}, but
not \emph{gnu}, because "*?NU" means `a word that ends with
``NU'' in upper case.'
Each of these words will be indexed in its own entry,
so there'll be a \emph{cat} and a \emph{cats} entry, but we'll
learn how to have them grouped presently. If a word matches several
underspecified forms, the more specific wins, e.g.
\emph{mammals} matches \texttt{mam?} and not \texttt{ma?},
and `starting-with' forms always win against `ending-with' ones,
no matter the degree of specificity, e.g. \emph{cat} matches
\texttt{c?} and not \texttt{?at}. Phrases, i.e. words
separated by blanks (like \emph{alley cat} above) can be
underspecified only at the end, i.e. you can say
\texttt{alley ca?} but not \texttt{?ley cat} (actually
you can try but it won't work). Finally, underspecified
parts are only the beginning or the end of a word, i.e.
you can't say \texttt{c?t}, and there should be only
one underspecification, i.e. \texttt{?a?} is forbidden.

\midbreak

Now we come to the interesting part in
\meta{word}\textcolor{red!80!black}{$=$\meta{entry}}, namely the
red part: \meta{entry} should be a pseudo-index entry,
as it were, i.e. it can be a normal index entry, as in

\begin{example}
\IndexList{another list}{%
  dog=mammal|textit,
  snail=Obviously Not Mammal,
  cat=mammal!pet,
  horse?=horse@{\bfseries horse}}
\end{example}

\noindent
Here, every occurrence of \emph{dog} will produce
an index entry at \emph{mammal} with the page number
in italic, \emph{snail} will index \emph{Obviously Not Mammal},
\emph{cat} will create a sub-entry \emph{pet} in the
\emph{mammal} entry and \emph{horse}, \emph{horses},
\emph{horseshoe}, etc., will create a bold entry
at \emph{horse}. So, as you can see, the left part
of the expression specifies which words should generate
an index entry, and the right part is the index entry
that should be generated. The latter is not case-insensitive
anymore: although \texttt{snail} is case-insensitive
and will fire on \emph{snail}, \emph{Snail} or
\emph{SNaIl}, the index entry itself will be as specified, i.e.
\emph{Obviously Not Mammal} and not \emph{obviously not mammal}.

Now you can index variations of a word under the
same entry. As I've just said, \emph{horse} and \emph{horses}
will both be indexed under \emph{horse}, as well as
all their case-variants, as we already know.
(\emph{Horseshoe} will go in that entry too, so beware).

The right part of those pairs is a `pseudo-index entry,'
and not a proper index entry, because the word to index
can be omitted, in which case the word that fires the
index entry will be used instead. More precisely, whenever
xeindex encounters one of the usual MakeIndex operators,
namely "!" (for a sub-entry), "|" (for a control sequence)
and "@" (to indicate the form of the entry irrespective
of alphabetical order), at the beginning of an index entry,
it reinterprets this entry with the the firing
word or phrase on its left. I.e.

\begin{example}
\IndexList{yet another list}{%
  dog=@dog (canis lupus familiaris),
  cat=!basic definition,
  horse?=|textbf}
\end{example}

\noindent
indexes every occurence of \emph{dog} as \emph{dog (canis lupus familiaris)},
but with the alphabetical order of \emph{dog},
every occurrence of \emph{cat} as a \emph{basic definition} subentry
in the \emph{cat} entry, and every occurrence of a word beginning with
\emph{horse} as an entry for this word with the page number in boldface.
Remember that the "\index" command is still available, so you can still
index \emph{cat} as \emph{cat} in your document.

It's obviously a very bad idea to say something like
"\IndexList{mylist}{cat=|(}", since this will fire "\index{cat|(}"
on every occurrence of \emph{cat}. So page ranges can't be declared
by xeindex (it would be a very bad idea anyway). On the other
hand, MakeIndex automatically creates page ranges as soon as
an entry is found on at least three successive pages, unless you run it
with the "-r" option.

If you want a comma in the right part of the entry, enclose
the entire entry, minus the MakeIndex operator if any, between braces, e.g.:

\begin{example}
\IndexList{writers}{Kafka={Kafka, Franz}}
\end{example}

\noindent
(This did not work in version 0.1, and now it's corrected
thanks to Simon Spiegel who indicated it to me.)

\DescribeMacro{\StopIndexList\marg{lists}}\macroskip\baselineskip
\DescribeMacro{\StopIndex}\macroskip2\baselineskip
\DescribeMacro{\NoIndex\marg{text}}
Here are some additional macros to let you regulate the flow of
the indexing frenzy.
"\StopIndexList" takes a comma-separated list of lists and turn them off.
"\StopIndex" turns off all lists.
"\NoIndex" simply prevents \meta{text} from being indexed. It's very important,
because it lets you prevent irrelevant indexation in the body of your
document. 

That's all you need to know to use xeindex. The next paragraph
describes how xeindex sets the parameters of xesearch; so if
you don't know xesearch and don't intend to use it, there's no need to
read what follows.

\midbreak

xeindex keeps xesearch's default search order, namely full words before
prefixes before suffixes, with case-sensitive tests first each time.
Affixes are modified, however: they're sorted by length (longer ones first)
and not kept in the order they were declared, and only one affix fires
in case of a successful test, instead of all the affixes of a given
test. You can modify these specifications since xeindex uses "!"-marked
replacement texts, so they won't embed each other, but then you might
end up with multiple entries and a lack of consistency.

You can use "\StartSearching" and "\StopSearching" instead of "\StopIndex",
which for the moment renders all lists unavailable. The former two
commands, however, will stop all lists defined by xesearch.

The default set of boundaries is left untouched, i.e. its members are:
".,;:-`'()[]{}"





\section*{Implementation}

\let\PrintMacro\printmacro
\DocStripMarginpar

Basic declarations and definitions.

\BoxTolerance\maxdimen
\ShortCode/
\CodeEscape!
\StopSearching
/
\ProvidesPackage{!FileName}[!FileDate !FileVersion Automatic index for XeLaTeX.]
/
\UndoCodeEscape
\StartSearching

/
\RequirePackage{makeidx,xesearch}
\makeatletter
\newif\ifxi@mark
\DeclareOption{mark}{\xi@marktrue}
\ProcessOptions
/

\DefineMacro\xi@Mark
\DefineMacro\xi@empty
\DefineMacro\xi@end
\DefineMacro\xi@Lists
"\xi@Mark" either shows the word and the corresponding line,
or it gobbles it. It is placed at the beginning of
the "\index" command, whose expansion is delayed accordingly.
/
\ifxi@mark
  \def\xi@Mark#1{***[#1:\the\inputlineno] }
\else
  \def\xi@Mark#1{}
\fi
\def\xi@empty{}
\def\xi@end{\xi@end}
\def\xi@Lists{}
/

\DefineMacro\IndexList
\DefineMacro\xi@IndexList
Most of the job is done by xesearch. What we need to do
is properly analyze the entry to launch an adequate search.
/
\def\IndexList{%
  \@ifstar{\def\xi@cs{*}\xi@IndexList}{\def\xi@cs{}\xi@IndexList}%
  }
\def\xi@IndexList#1#2{%
  \def\xi@ListName{#1}%
  \edef\xi@Lists{\xi@Lists#1,}%
  \unless\ifcsname#1@xeindex\endcsname
    \csname#1@xeindex\endcsname
/

\noindent
When a index list is created, we associate five xesearch
lists with it: one is for words and affixes that should index
themselves in lower case.
/
    \SearchList{#1@xeindex@ncs@normal@list}{%
      \def\xi@Word{##1}%
      \lowercase{\expandafter\index\expandafter{\xi@Mark\xi@Word##1}}}{}%
/

\noindent
Another one is for case-sensitive words and affixes.
/
    \SearchList{#1@xeindex@cs@normal@list}{%
      \expandafter\index\expandafter{\xi@Mark{##1}##1}}{}%
/

\noindent
And the last three are for words and affixes that launch
a special entry, which is stored in an associated command.
/
    \SearchList{#1@xeindex@ncs@special@list}{%
      \lowercase{\csname##1@#1@xeindex@entry\endcsname}{##1}}{}%
    \SearchList{#1@xeindex@cs@special@list}{%
      \csname##1@#1@xeindex@entry\endcsname{##1}}{}%
    \SearchList{#1@xeindex@affix@special@list}{%
      \csname\AffixFound @#1@xeindex@entry\endcsname{##1}}{}%
  \fi
  \xi@ParseList#2,\xi@end,%
  }
/

\DefineMacro\xi@ParseList
This macro recursively tests each entry in "\SearchList"
and feed it to "\xi@ParseEntry" with an additional "="
to check for the right part. It also adds "\xi@cs", which
was defined do "*" in case "\SearchList" was starred.
/
\def\xi@ParseList#1,{%
  \def\xi@temp{#1}%
  \ifx\xi@temp\xi@end
    \let\xi@next\relax
  \else
    \expandafter\xi@ParseEntry\xi@cs#1=\xi@end
    \let\xi@next\xi@ParseList
  \fi\xi@next
  }
/


\DefineMacro\xi@ParseEntry
This one analyses the entry. If the third argument
is empty, then there is no $=$\meta{entry} part
in the entry. In this case we add the word or
affix to one of the two simple lists, depending
on its case-sensitivity.
/
\def\xi@ParseEntry#1#2=#3\xi@end{%
  \def\xi@temp{#3}%
  \ifx\xi@temp\xi@empty
    \expandafter\if\noexpand#1*%
      \AddToList!{\xi@ListName @xeindex@cs@normal@list}{#1#2}%
    \else
      \AddToList!{\xi@ListName @xeindex@ncs@normal@list}{#1#2}%
    \fi
/

\noindent
Otherwise we feed the right part to "\xi@MakeEntry" which
sets the "\ifxi@NoWord" switch. We also check whether the
word is an affix or not, and whether it is case-sensitive.
The word is then associated to the right list and an
associated macro is created.
/
  \else
    \xi@MakeEntry#3%
    \expandafter\if\noexpand#1*%
      \xi@CheckAffix#2?\xi@end
      \ifxi@Affix
          \AddToList!{\xi@ListName @xeindex@affix@special@list}{#1#2}%
          \expandafter\edef\csname\xi@Affix @\xi@ListName @xeindex@entry\endcsname##1{%
            \unexpanded{\expandafter\index\expandafter}{%
              \noexpand\xi@Mark{##1}\ifxi@NoWord##1\fi\unexpanded\expandafter{\xi@temp}}%
            }%
      \else
        \AddToList!{\xi@ListName @xeindex@cs@special@list}{#1#2}%
          \expandafter\edef\csname#2@\xi@ListName @xeindex@entry\endcsname##1{%
            \unexpanded{\expandafter\index\expandafter}{%
              \noexpand\xi@Mark{##1}\ifxi@NoWord#2\fi\unexpanded\expandafter{\xi@temp}}%
            }%
      \fi
    \else
      \xi@CheckAffix#1#2?\xi@end
      \ifxi@Affix
          \AddToList!{\xi@ListName @xeindex@affix@special@list}{#1#2}%
          \expandafter\edef\csname\xi@lcAffix @\xi@ListName @xeindex@entry\endcsname##1{%
            \unexpanded{\def\xi@Word}{##1}%
            \noexpand\lowercase{%
              \unexpanded{\expandafter\index\expandafter}{%
                \unexpanded{\xi@Mark{\xi@Word}}%
                \ifxi@NoWord##1\fi\unexpanded\expandafter{\xi@temp}}%
              }%
            }%
      \else
        \AddToList!{\xi@ListName @xeindex@ncs@special@list}{#1#2}%
        \lowercase{%
          \expandafter\edef\csname#1#2@\xi@ListName @xeindex@entry\endcsname##1{%
            \unexpanded{\def\xi@Word}{##1}%
            \unexpanded{\expandafter\index\expandafter}{%
              \unexpanded{\xi@Mark{\xi@Word}}%
              \ifxi@NoWord#1#2\fi\unexpanded\expandafter{\xi@temp}}%
            }%
          }%
      \fi
    \fi
  \fi
  }
/

\DefineMacro\xi@MakeEntry
This determines whether the entry starts with one
of the MakeIndex operators. 
/
\newif\ifxi@NoWord
\def\xi@exclam{!} \def\xi@at{@} \def\xi@bar{|}
\def\xi@MakeEntry#1#2={%
  \def\xi@temp{#1#2}%
  \xi@NoWordtrue
  \unless\ifx\xi@temp\xi@exclam
    \unless\ifx\xi@temp\xi@at
      \unless\ifx\xi@temp\xi@bar
        \xi@NoWordfalse
      \fi
    \fi
  \fi
  }
/

\DefineMacro\xi@CheckAffix
If the first argument is "?", then the word is
unspecified at the beginning. Otherwise, if
the third argument is not empty, then it is unspecified
at the end (because we added a "?" when giving the
word to this macro). In case the "?" is misplaced,
xesearch will detect it later.
/
\newif\ifxi@Affix
\def\xi@CheckAffix#1#2?#3\xi@end{%
  \xi@Affixfalse
  \expandafter\if\noexpand#1?%
    \xi@Affixtrue
    \def\xi@Affix{#2}%
    \lowercase{\def\xi@lcAffix{#2}}%
  \else
    \def\xi@@temp{#3}%
    \unless\ifx\xi@@temp\xi@empty
      \xi@Affixtrue
      \def\xi@Affix{#1#2}%
      \lowercase{\def\xi@lcAffix{#1#2}}%
    \fi
  \fi
  }
/

\DefineMacro\StopIndexList
\DefineMacro\xi@StopIndexList
\DefineMacro\StopIndex
\DefineMacro\NoIndex
These are straightforward.
/
\def\StopIndexList#1{%
  \xi@StopIndexList#1,\xi@end,%
  }%
\def\xi@StopIndexList#1,{%
  \def\xi@temp{#1}%
  \ifx\xi@temp\xi@end
    \let\xi@next\relax
  \else
    \StopList{%
      #1@xeindex@ncs@normal@list,%
      #1@xeindex@cs@normal@list,%
      #1@xeindex@cs@normal@list,%
      #1@xeindex@ncs@special@list,%
      #1@xeindex@cs@special@list,%
      #1@xeindex@affix@special@list%
      }%
    \let\xi@next\xi@StopIndexList
  \fi\xi@next
  }
\def\StopIndex{%
  \expandafter\xi@StopIndexList\xi@Lists\xi@end,%
  }
\def\NoIndex#1{%
  \bgroup
  \StopIndex
  #1%
  \egroup
  }
/

\DefineMacro\xi@PrintIndex
Finally, we patch "\printindex" so it won't be searched,
and sets xesearch's parameters.
/
\let\xi@PrintIndex\printindex \def\printindex{\StopIndex\xi@PrintIndex}
\SortByLength{pPsS} \SearchOnlyOne{pPsS}
\makeatother
/
\end{document}
	
